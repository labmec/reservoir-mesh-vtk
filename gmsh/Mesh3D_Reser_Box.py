import gmsh as gm
import sys
import numpy as np


import gmsh
import numpy as np



if __name__ == "__main__":
    gm.initialize()
    gm.model.add("mesh3D_py_rev08")

    # ===============================================================================
    # MESHING PARAMETERS FOR UNIFY POINTS AND TOLERANCES IN GEOMETRY DID NOT TESTED YET
    # ===============================================================================
    gm.option.setNumber("Geometry.MatchMeshTolerance", 1e-12)
    gm.option.setNumber("Geometry.Tolerance", 1e-16)
    gm.option.setNumber("Mesh.ToleranceReferenceElement", 1e-10)
    gm.option.setNumber("General.Terminal", 1)
    gm.option.setNumber("Geometry.SnapPoints", 0) # snap point on (1) or off (0)

    # ===============================================================================
    # GEOMETRY PARAMETERS
    # ===============================================================================
    # WELLBORE
    lw: float = 8. # length (m) of the wellbore
    Rw: float = 0.5 # radius (m) of the wellbore
    
    # RESERVOIR
    delta = 20
       
    # PARAMETER TO INCREASE THE BOX SIZE AROUND THE RESERVOIR
    Sr: float = 8.0
    
    lr: float = lw + delta * Rw # length (m) of the reservoir
    Wr: float = delta * Rw # width (m) of the reservoir
    Hr: float = delta * Rw  # height (m) of the reservoir

    # lr: float = 6.0 # length (m) of the reservoir
    # Wr: float = 1.0 # width (m) of the reservoir
    # Hr: float = 1.0 # height (m) of the reservoir

    # WELLBORE ECCENTRICITY
    ecc: float = 0.0

    max_vert_disp = Hr/2 - Rw # vertical displacement limit => 1/2 - 0.2 = 0.3 m

    # WELLBORE DIVISION
    h_div: int = 8 # horizontal division
    r_div: int = 4 # radial division
    l_div: int = 10 # axial division
    p_res: float = 1.6 # progression coefficient of the reservoir mesh (1.6)
    p_well: float = 0.05 # progression coefficient of the wellbore mesh (bump scheme) (0.3)
    
    s = np.sin(np.pi/4)
    
    # ===============================================================================
    # POINTS OF THE HEEL PART (pn_wb) BASE
    # ===============================================================================
    p1_wb= gm.model.occ.addPoint(0, 0, 0 + ecc*max_vert_disp, 1.0, tag = 1) #center domain point of the wellbore
    p2_wb = gm.model.occ.addPoint(0, -Rw*s, Rw*s + ecc*max_vert_disp, 1.0, tag = 2)
    p3_wb = gm.model.occ.addPoint(0, Rw*s, Rw*s + ecc*max_vert_disp, 1.0, tag = 3)
    p4_wb = gm.model.occ.addPoint(0, Rw*s, -Rw*s + ecc*max_vert_disp, 1.0, tag = 4)
    p5_wb = gm.model.occ.addPoint(0, -Rw*s, -Rw*s + ecc*max_vert_disp, 1.0, tag = 5)
    print(type(p1_wb))

    # ===============================================================================
    # CIRCLE AND LINES OF THE HEEL PART (cn_w) BASE TO BE EXTRUDED
    # ===============================================================================
    c1_wb = gm.model.occ.addCircleArc(p2_wb, p1_wb, p3_wb, tag = 1)
    c2_wb = gm.model.occ.addCircleArc(p3_wb, p1_wb, p4_wb, tag = 2)
    c3_wb = gm.model.occ.addCircleArc(p4_wb, p1_wb, p5_wb, tag = 3)
    c4_wb = gm.model.occ.addCircleArc(p5_wb, p1_wb, p2_wb, tag = 4)

    gm.model.occ.synchronize()

    # ===============================================================================
    # EXTRUDE THE HEEL PART
    # ===============================================================================
    # Equivalent to: ids() = Extrude {Lw, 0, 0} { Line{1:4}; }
    ids = gm.model.occ.extrude([(1, c) for c in [c1_wb, c2_wb, c3_wb, c4_wb]], lw, 0, 0)
    
    
    # here its doesnt matter if we estrude pro the points or the lines, because gmsh will create the same geometry
    #print(f'ids: {ids}')
    # ids is a list of tuples ( dim, tag) who discrive new entitie created 
    # surface created by the extrusion
    # from now here we have the base of the wellbore extruded ( just a cylinder so far)
    
    gm.model.occ.synchronize()
    
    # POINTS GENERATED BY THE EXTRUSION
    p6_wb = p2_wb + 4 
    p7_wb = p3_wb + 4
    p8_wb = p4_wb + 4
    p9_wb = p5_wb + 4  
    
    # LINES GENERATED BY THE EXTRUSION
    l6_wb = 6
    l8_wb = 8
    l10_wb = 10
    l5_wb = 5
    
    # CIRCLE GENERATED BY THE EXTRUSION
    c7_wb = 7
    c12_wb = 12
    c11_wb = 11
    c9_wb = 9

    # ===============================================================================
    # POINTS AND LINES OF THE RESERVOIR PART ( the box contour)
    # ===============================================================================
    # close to the WELLBORE HEEL (pn_re))
    p10_re = gm.model.occ.addPoint(-(lr - lw) / 2, -Wr / 2,  Hr / 2, 1.0, tag = 10)
    p11_re = gm.model.occ.addPoint(-(lr - lw) / 2, Wr / 2, Hr / 2, 1.0, tag = 11)
    p12_re = gm.model.occ.addPoint(-(lr - lw) / 2, Wr / 2, -Hr / 2, 1.0, tag = 12)
    p13_re = gm.model.occ.addPoint(-(lr - lw) / 2, -Wr / 2, -Hr / 2, 1.0, tag= 13)


    # close to the WELLBORE TOE (pn_re)
    p14_re = gm.model.occ.addPoint(lw + (lr - lw) / 2, -Wr / 2, Hr / 2, 1.0,tag= 14 )
    p15_re = gm.model.occ.addPoint(lw + (lr - lw) / 2, Wr / 2, Hr / 2, 1.0, tag= 15)
    p16_re = gm.model.occ.addPoint(lw + (lr - lw) / 2, Wr / 2, -Hr / 2, 1.0, tag = 16)
    p17_re = gm.model.occ.addPoint(lw + (lr - lw) / 2, -Wr / 2, -Hr / 2, 1.0, tag = 17)

    # ==============================================================================
    # LINES OF THE RESERVOIR PART
    # ==============================================================================
   
    # ALONG THE RESERVOIR LENGTH (the box sides, horizontal line on x up and down) 
    l13_rex = gm.model.occ.addLine(p10_re, p14_re, tag=13)
    l14_rex = gm.model.occ.addLine(p11_re, p15_re, tag=14)
    l15_rex = gm.model.occ.addLine(p12_re, p16_re, tag=15)
    l16_rex = gm.model.occ.addLine(p13_re, p17_re, tag=16)  

    #LINES CLOSE TO THE WELLBORE AXIS ( lines parallel to the wellbore axis ln_re in y direction)
    l17_rey = gm.model.occ.addLine(p10_re, p11_re, tag=17)
    l19_rey = gm.model.occ.addLine(p12_re, p13_re, tag=19)
    l21_rey = gm.model.occ.addLine(p14_re, p15_re, tag=21)
    l23_rey = gm.model.occ.addLine(p16_re, p17_re, tag=23)

    #LINES CLOSE TO THE WELLBORE TOE ( lines perperdicular to the wellbore axis ln_re in z direction)
    l18_rez = gm.model.occ.addLine(p11_re, p12_re, tag=18)
    l20_rez = gm.model.occ.addLine(p10_re, p13_re, tag=20)
    l22_rez = gm.model.occ.addLine(p15_re, p16_re, tag=22)
    l24_rez = gm.model.occ.addLine(p14_re, p17_re, tag=24)

    # LINES FROM THE RESERVIOR TO THE WELLBORE HEEL (DIAGONALS ln_di)
    l25_di = gm.model.occ.addLine(p2_wb, p10_re, tag=25)
    l26_di = gm.model.occ.addLine(p3_wb, p11_re, tag=26)
    l27_di = gm.model.occ.addLine(p4_wb, p12_re, tag=27)
    l28_di = gm.model.occ.addLine(p5_wb, p13_re, tag=28)

    # LINES FROM THE RESERVIOR TO THE WELLBORE TOE (DIAGONALS)
    # On Gmsh when we create an extrusion it internally knows tha p2+4 menas a point create by an extrusion os p2
    # since on python we dont have this, so Gmsh dont generate automaticallu the variabvles p2 + 4, 
    # instead it retuns a list of tuples ids()
    # as .geo doesnt have correspondence direct and documentation we will crete the variables below,
    # assuming that Gmsh atributes new ids in a incremental way

   
    # LINES FROM THE RESERVIOR TO THE WELLBORE HEEL (DIAGONALS ln_di, the other side)
    l29_di = gm.model.occ.addLine(p6_wb, p14_re, tag=29)
    l30_di = gm.model.occ.addLine(p7_wb, p15_re, tag=30)
    l31_di = gm.model.occ.addLine(p8_wb, p16_re, tag=31)
    l32_di = gm.model.occ.addLine(p9_wb, p17_re, tag=32)

    gm.model.occ.synchronize()
    
    # ===============================================================================
    # CREATE CURVE LOOPS AND SURFACES OF THE RESERVOIR PART
    # ===============================================================================
    cl1_zy = gm.model.occ.addCurveLoop([l17_rey, l18_rez, l19_rey, l20_rez])   # close to the wellbore heel planeZY
    cl2_zy = gm.model.occ.addCurveLoop([l21_rey, l22_rez, l23_rey, l24_rez])   # close to the wellbore toe plane ZY
    cl3_zx = gm.model.occ.addCurveLoop([l13_rex, l24_rez, -l16_rex, l20_rez])    # -negative side plane ZX
    cl4_zx = gm.model.occ.addCurveLoop([l14_rex, l22_rez, l15_rex, l18_rez])    # +positive side plane ZX

    # SUFACES CONNECTING THE RESERVOIR TO THE WELLBORE
    sf1 = gm.model.occ.addPlaneSurface([cl1_zy]) 
    sf2 = gm.model.occ.addPlaneSurface([cl2_zy]) 
    sf3 = gm.model.occ.addPlaneSurface([cl3_zx]) 
    sf4 = gm.model.occ.addPlaneSurface([cl4_zx]) 
    gm.model.occ.synchronize()
    
    # RES CAP ROCKS
    cl5_si = gm.model.occ.addCurveLoop([l17_rey, l14_rex, -l21_rey,-l13_rex])   # side surface reservoir cap rock
    cl6_si = gm.model.occ.addCurveLoop([l19_rey, l16_rex, -l23_rey, -l15_rex])  # otherside surface reservoir cap rock
    
    # SURFACES CONNECTING THE RESERVOIR TO THE WELLBORE
    sf5 = gm.model.occ.addPlaneSurface([cl5_si])
    sf6 = gm.model.occ.addPlaneSurface([cl6_si])

    # INCLINE SURFACES CLOSE TO THE WELLBORE HEEL
    cl7 = gm.model.occ.addCurveLoop([c1_wb, -l26_di, -l17_rey, l25_di])   # diagonal side wellbore to reservoir
    cl8 = gm.model.occ.addCurveLoop([c2_wb, -l27_di, -l18_rez, l26_di])   # diagonal top wellbore to reservoir
    cl9 = gm.model.occ.addCurveLoop([c3_wb, -l28_di, -l19_rey, l27_di])   # diagonal bottom wellbore to reservoir
    cl10 = gm.model.occ.addCurveLoop([c4_wb, -l25_di, -l20_rez, l28_di])  # diagonal side wellbore to reservoir
    
    # SURFACES CONNECTING THE RESERVOIR TO THE WELLBORE
    sf7 = gm.model.occ.addSurfaceFilling(cl7)
    sf8 = gm.model.occ.addSurfaceFilling(cl8)
    sf9 = gm.model.occ.addSurfaceFilling(cl9)
    sf10 = gm.model.occ.addSurfaceFilling(cl10)
    gm.model.occ.synchronize()
    
    # ===============================================================================
    # INCLINED SURFACE CLOSE TO THE WELLBORE
    # ===============================================================================

    cl11 = gm.model.occ.addCurveLoop([c7_wb, l30_di, -l21_rey, l29_di])    # diagonal side wellbore to reservoir
    cl12 = gm.model.occ.addCurveLoop([c9_wb, -l31_di, -l22_rez, l30_di])   # diagonal top wellbore to reservoir
    cl13 = gm.model.occ.addCurveLoop([c11_wb, -l32_di, -l23_rey, l31_di])  # diagonal bottom wellbore to reservoir
    cl14 = gm.model.occ.addCurveLoop([c12_wb, -l29_di, -l24_rez, l32_di])  # diagonal y-negative wellbore to reservoir

    # SURFACES CONNECTING THE RESERVOIR TO THE WELLBORE
    sf11 = gm.model.occ.addSurfaceFilling(cl11)
    sf12 = gm.model.occ.addSurfaceFilling(cl12)
    sf13 = gm.model.occ.addSurfaceFilling(cl13)
    sf14 = gm.model.occ.addSurfaceFilling(cl14)
    gm.model.occ.synchronize()
    
    # ===============================================================================
    # INCLINED SURFACES OF THE WELLBORE
    # ===============================================================================
    cl15 = gm.model.occ.addCurveLoop([l25_di, l5_wb, -l29_di, -l13_rex])  #  surface side of wellbore to top reservoir negative
    cl16 = gm.model.occ.addCurveLoop([l26_di, l6_wb, -l30_di, -l14_rex])  #  surface side of wellbore to bottom reservoir positive

    # SURFACES CONNECTING THE RESERVOIR TO THE WELLBORE
    sf15 = gm.model.occ.addPlaneSurface([cl15])
    sf16 = gm.model.occ.addPlaneSurface([cl16])
    gm.model.occ.synchronize()
    
    # ===============================================================================
    # INCLINED SURFACES OF THE WELLBORE NEGATIVE , BOTTOM AND POSITIVE TOP
    # ===============================================================================
    cl17 = gm.model.occ.addCurveLoop([l28_di, l10_wb, -l32_di, -l16_rex])  # surface side of wellbore to bottom reservoir negative
    cl18 = gm.model.occ.addCurveLoop([l27_di, l8_wb, -l31_di, -l15_rex])   # surface side of wellbore to top reservoir positive
    cl19_he = gm.model.occ.addCurveLoop([c1_wb, c2_wb, c3_wb, c4_wb])         # surface wellbore heel 

    # SURFACES CONNECTING THE RESERVOIR TO THE WELLBORE
    sf17 = gm.model.occ.addPlaneSurface([cl17])
    sf18 = gm.model.occ.addPlaneSurface([cl18])
    sf19_he = gm.model.occ.addPlaneSurface([cl19_he])
    gm.model.occ.synchronize()

    # ===============================================================================
    # SURFACE IN THE WELLBORE AND WELBORE TOE
    # ===============================================================================

    cl20_to = gm.model.occ.addCurveLoop([c7_wb, c9_wb, c11_wb, c12_wb])  # surface wellbore toe
    sf20_to = gm.model.occ.addPlaneSurface([cl20_to])  # wellbore toe
    gm.model.occ.synchronize()
    
    # ===============================================================================
    # CREATE VOLUME
    # ===============================================================================

    sfl1 = gm.model.occ.addSurfaceLoop([1, sf7, sf11, sf15, sf16, sf5]) # top verrificar 1 e 2 f6 e f5
    sfl2 = gm.model.occ.addSurfaceLoop([3, sf9, sf13, sf17, sf18, sf6]) # bottom
    sfl3 = gm.model.occ.addSurfaceLoop([4, sf10, sf14, sf15, sf17, sf3]) # negative y
    sfl4 = gm.model.occ.addSurfaceLoop([2, sf8, sf12, sf16, sf18, sf4]) # positive y
    sfl5 = gm.model.occ.addSurfaceLoop([sf19_he,sf7,sf8,sf9,sf10,sf1]) # wellbore
    sfl6 = gm.model.occ.addSurfaceLoop([sf20_to,sf11,sf12,sf13,sf14,sf2]) # wellbore toe

    vl1 = gm.model.occ.addVolume([sfl1])
    vl2 = gm.model.occ.addVolume([sfl2])
    vl3 = gm.model.occ.addVolume([sfl3])
    vl4 = gm.model.occ.addVolume([sfl4])
    vl5 = gm.model.occ.addVolume([sfl5])
    vl6 = gm.model.occ.addVolume([sfl6])
    gm.model.occ.synchronize()
    
    # ===============================================================================
    # APPLY TRANSFINITE PROGESSSION TO LINES
    # ===============================================================================
    
    lines_wellbore = [l25_di, l26_di, l27_di, l28_di, l29_di, l30_di, l31_di, l32_di]
    for line in lines_wellbore:
        gm.model.mesh.setTransfiniteCurve(line, h_div, coef = p_res)

    heel_toe_lines = [c1_wb, c2_wb, c3_wb, c4_wb, c7_wb, c9_wb, c11_wb, c12_wb]
    for line in heel_toe_lines:
        gm.model.mesh.setTransfiniteCurve(line, r_div)

    res_lines = [l17_rey, l18_rez, l20_rez, l19_rey, l22_rez, l23_rey, l21_rey, l24_rez]
    for line in res_lines:
        gm.model.mesh.setTransfiniteCurve(line, r_div)

    horizontal_lines = [l13_rex, l14_rex, l15_rex, l16_rex]
    for line in horizontal_lines:
        gm.model.mesh.setTransfiniteCurve(line, l_div)

    bump_lines = [l5_wb, l6_wb, l8_wb, l10_wb]
    for line in bump_lines:
        # chamar o loop da função
        gm.model.mesh.setTransfiniteCurve(line, l_div,"Bump", coef = p_well)
       
    gm.model.occ.synchronize()
    
    # ===============================================================================
    # SET PHYSICAL GROUPS
    # ===============================================================================
    
    # PHYSICAL CURVES 
    gm.model.addPhysicalGroup(1, [l5_wb], tag =100, name= "curve_wellbore")
    gm.model.addPhysicalGroup(1, [c7_wb, c9_wb, c11_wb, c12_wb], tag =101, name= "curve_toe")
    gm.model.addPhysicalGroup(1, [c1_wb, c2_wb, c3_wb, c4_wb], tag =102, name= "curve_heel")
    #gm.model.addPhysicalGroup(1, [l6_wb, l8_wb, l10_wb], tag =103, name= "curve_heel")

    # PHYSICAL SURFACES
    gm.model.addPhysicalGroup(2, [c1_wb, c2_wb, c3_wb, c4_wb], tag = 103, name= "surface_wellbore_cylinder")
    gm.model.addPhysicalGroup(2, [sf20_to], tag = 104, name = "surface_wellbore_toe")
    gm.model.addPhysicalGroup(2, [sf19_he], tag = 105, name = "surface_wellbore_heel")
    gm.model.addPhysicalGroup(2, [sf1, sf2, sf3, sf4], tag = 106, name = "surface_farfield")
    gm.model.addPhysicalGroup(2, [sf5, sf6], tag = 107, name = "surface_cap_rock")
    
    # PHYSICAL POINTS
    gm.model.addPhysicalGroup(0, [2], tag = 108, name = "point_wellbore")
    gm.model.addPhysicalGroup(0, [6], tag = 109, name = "point_toe")
    
    # PHYSICAL VOLUMES
    all_volumes = [ volume[1] for volume in gm.model.getEntities(3)]
    gm.model.addPhysicalGroup(3, all_volumes, tag = 110, name = "volume_nearwell")

    # gm.model.addPhysicalGroup(3, [vl6], tag = 111, name = "volume_reservoir_6")
    # gm.model.addPhysicalGroup(3, [vl5], tag = 112, name = "volume_reservoir_5")
    # gm.model.addPhysicalGroup(3, [vl4], tag = 113, name = "volume_reservoir_4")
    # gm.model.addPhysicalGroup(3, [vl3], tag = 114, name = "volume_reservoir_3")
    # gm.model.addPhysicalGroup(3, [vl2], tag = 115, name = "volume_reservoir_2")
    # gm.model.addPhysicalGroup(3, [vl1], tag = 116, name = "volume_reservoir_1")

    gm.model.occ.synchronize()
    
    
    gmode = gm.model.getEntities(dim = 2)
    
    for s in gm.model.getEntities(dim=2):
        gm.model.mesh.setTransfiniteSurface(s[1])
    #    gm.model.mesh.setRecombine(2, s[1])  # quadrilateral elements

    for v in gm.model.getEntities(dim=3):
        gm.model.mesh.setTransfiniteVolume(v[1])
        
    for s in gm.model.getEntities(dim=2):
        gm.model.mesh.setRecombine(2, s[1])  # quadrilateral elements


    # ==============================================================================
    #                          MESH AROUND IT ALL BIGGER RESERVOIR
    # ==============================================================================
    
    #function to crate and move the box around the reservoir
    def bigger_box(ex: float, ey: float, ez: float, edge= False, lmt = False):
    
        if (edge is False) != (lmt is False):
            raise ValueError("edge or limits is not given. Please provide both or none of them.")
    
        if any(v < -1.0 or v > 1.0 for v in (ex, ey, ez)):
            raise ValueError("ex, ey and ez must be between -1 and 1.")
        
        if edge < 0:
            raise ValueError("edge must be a non-negative value.")
          
        # parametrization of the bigger box the sx must be between -1 and 1 
        # and the limits of the bigger box are given by s ( the multiplication 
        # factior) multiply by 2 minos 2:
        # its a linear function where sx(1) = 2*s-2, sx(0) = s-1 and sx(-1) = 0
        # so bean a function as y = ax + b, we have b = s -1 and a = s -1
        # so the final function is sx(nx) = (s-1)*nx + (s-1) witch is iqual to sx (nx) = (s-1)*(nx + 1)
        
        sx: float = (Sr - 1) * (ex + 1) 
        sy: float = (Sr - 1) * (ey + 1) 
        sz: float = (Sr - 1) * (ez + 1)
        
        # adjustments to not cut the reservoir
        # the ideia is when the n get too close to tghe sides it wont get more close 
        # than the parameters set as se sx, sy or sz subtracting the reservoir size divided by 8**2
        
        # the lmt ( limit) is to define a limit when the box get too close to the edge 
        # of the reservior. It garantee that when the box is getting close it do not jump to the 
        # inteval edge
        
        if edge and lmt > 0:
  
            if ex >= lmt:
                sx = sx - edge*ex
            if ex <= -lmt:
                sx = sx + edge*(-ex)
            if ey >= lmt:
                sy = sy - edge*ey
            if ey <= -lmt:
                sy = sy + edge*(-ey)
            if ez >= lmt:
                sz = sz - edge*ez
            if ez <= -lmt:
                sz = sz + edge*(-ez)
            
        # coordinates and based on the coordinates of the point 13 in the reservoir 
        x: float = -(lr -lw) /2
        y: float = -Wr /2
        z: float = -Hr /2
        
        # size of the bigger box according to the reservoir size multipy by s 
        lrbb: float = Sr*(lr-lw) + lw
        Wrbb: float = Sr*Wr
        Hrbb: float = Sr*Hr   
        
        # the coordinate of the bigger box according to the coordinate of the reservoir
        x = x *(1 + sx) 
        y = y *(1 + sy)
        z = z *(1 + sz)
               
        # so the output is basically the parameters sx, sy, sz, ( witch controls the position
        # of the reservio inside the big box ) x, y, z, lrbb, Wrbb, Hrbb
        return sx, sy, sz, x, y, z, lrbb, Wrbb, Hrbb
    
    # nx. ny and nz goes from -1 to 1 and define the position of the box around the reservoir
    # so the output is basically the parameters sx, sy, sz, ( witch controls the position
    # of the reservio inside the big box ) x, y, z, lrbb, Wrbb, Hrbb
    # for the bigger box function you can also set the limit (lmt) of approach to the reservoir
    # and the edge correction to not cut the reservoir (edge),
    sx, sy, sz, x, y, z, lrbb, Wrbb, Hrbb =bigger_box(ex = 0.0, ey = 0.0, ez = 0.0)
    
    # create the bigger box
    vl8 = gm.model.occ.addBox(x , y , z , lrbb, Wrbb, Hrbb, tag= 19)
            
    #box based in the reservoir surfaces 
    surf_box = gm.model.occ.addSurfaceLoop([sf1, sf2, sf3, sf4, sf5, sf6]) 
    vol_box = gm.model.occ.addVolume([surf_box])
    
    ar1 = gm.model.occ.cut([(3, vl8)], [(3, vol_box)], tag= 9)
    gm.model.occ.remove([(3, vl8)], recursive=False)
    gm.model.occ.remove([(3, vol_box)], recursive=False)

    result_entities = ar1[0]

    # external surfaces fo the bigger box (out_bigger_box [obb])
    sf29_obb = 29
    sf30_obb = 30
    sf31_obb = 31
    sf32_obb = 32
    sf33_obb = 33
    sf34_obb = 34
    
    gm.model.occ.synchronize()

    vol_tags = [tag for (dim, tag) in result_entities if dim == 3]
    pg = gm.model.addPhysicalGroup(3, vol_tags, name= "volume_reservoir")
    # gm.model.setPhysicalName(3, pg, "volume_reservoir")

    gm.model.addPhysicalGroup(2, [sf29_obb, sf30_obb, sf31_obb, sf32_obb, sf33_obb, sf34_obb],tag = 111, name= "surface_farfield_reservoir")


    gm.model.occ.synchronize()
    
    # ==============================================================================
    #                     END OF THE MESH AROUND IT ALL BIGGER RESERVOIR
    # ==============================================================================


    gm.model.occ.remove([(0, p1_wb)])  # remove center point of the wellbore
    gm.model.occ.synchronize()


    # THREADS NUMBER
    gm.option.setNumber("General.NumThreads", 4)

    # SMOOTHING OPTION
    gm.option.setNumber("Mesh.Smoothing", 0)
    
    
    surfs = gm.model.occ.getEntities(dim=2)
    print("Superfícies existentes:", surfs)

    # ==============================================================================
   
    # 2D MESH
    gm.model.mesh.generate(2)
    
    # gm.model.mesh.removeDuplicateNodes()  # remove nós duplicados
    # gm.model.mesh.removeDuplicateElements()  # remove elementos duplicados
    gm.model.occ.synchronize()
    

    
    # ===============================================================================
    #Loop de otimização Laplace2D
    for k in range(41):  # 0 a 40
        gm.model.mesh.optimize("Laplace2D")
        print(f"k = {k}")

    #gm.model.occ.remove_all_duplicates()
    
    # Malha 3D
    gm.model.mesh.generate(3)
    
    gm.model.mesh.removeDuplicateNodes()  # remove nós duplicados
    gm.model.mesh.removeDuplicateElements()  # remove elementos duplicados
    

    # ===============================================================================
    # EXHIBIT THE MODEL SO FAR
    # ===============================================================================
    gm.write("/home/erick/dev/Gmsh/TestErick/gmsh/Moving_Reservoir.msh")

    
    if '-nopopup' not in sys.argv:
        gm.fltk.run()
    
    gm.finalize()